{"title":"QianmuZheng_Assignment4","markdown":{"yaml":{"title":"QianmuZheng_Assignment4","output":"html_document","date":"2025-11-10"},"headingText":"Step 1: Data Loading & Preparation","containsRefs":false,"markdown":"\nGraffiti is one of the most common urban maintenance issues in Chicago.\nIn this step, I downloaded the 311 Graffiti Removal service request data from the City of Chicago Data Portal.\n\n```{r}\n# Step 1: Load and Prepare Data\n\nlibrary(tidyverse)\nlibrary(sf)\nlibrary(jsonlite)\nlibrary(lubridate)\n\n# Load Graffiti Removal 311 data from Chicago Open Data API\nurl <- \"https://data.cityofchicago.org/resource/hec5-y4x5.json?$limit=50000\"\n\ndata_raw <- fromJSON(url)\n\n```\n\n```{r}\n# Select and clean relevant columns\ndata_clean <- data_raw %>%\n  select(service_request_number,\n         creation_date,\n         completion_date,\n         status,\n         street_address,\n         latitude,\n         longitude,\n         ward,\n         community_area) %>%\n  mutate(\n    creation_date = ymd_hms(creation_date),\n    completion_date = ymd_hms(completion_date),\n    year = year(creation_date),\n    month = month(creation_date, label = TRUE),\n    day = day(creation_date)\n  ) %>%\n  drop_na(latitude, longitude)\n\n```\n\n```{r}\n# Convert to spatial (sf object)\ndata_sf <- st_as_sf(\n  data_clean,\n  coords = c(\"longitude\", \"latitude\"),\n  crs = 4326\n)\n```\n\n```{r}\nlibrary(ggplot2)\nlibrary(sf)\nlibrary(dplyr)\n\nggplot() +\n  geom_sf(data = data_sf, aes(), \n          color = \"#e41a1c\", alpha = 0.4, size = 0.6) +\n\n  labs(\n    title = \"Spatial Distribution of Street Light Out Reports (Chicago)\",\n    subtitle = \"Each point represents a 311 service request for streetlight outage\",\n    caption = \"Source: City of Chicago Open Data Portal\"\n  ) +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(size = 15, face = \"bold\"),\n    plot.subtitle = element_text(size = 12),\n    plot.caption = element_text(size = 9, color = \"gray40\"),\n    panel.background = element_rect(fill = \"aliceblue\")\n  )\n\n```\n\n## Step 2: Fishnet Grid Creation\nIn this step, I created a 500-meter fishnet grid across the City of Chicago to aggregate the Graffiti Removal 311 requests. By counting how many graffiti reports fall into each grid cell, we can visualize where graffiti problems are concentrated and prepare the data for spatial regression analysis.\n\n```{r}\ndata_proj <- st_transform(data_sf, crs = 26971)\n\nbbox <- st_bbox(data_proj)\n\nfishnet <- st_make_grid(\n  st_as_sfc(bbox),\n  cellsize = 500,\n  square = TRUE\n) %>%\n  st_sf() %>%\n  mutate(grid_id = row_number())\n```\n\n```{r}\n# Visualize the fishnet grid outline\nggplot() +\n  geom_sf(data = fishnet, fill = NA, color = \"grey40\", size = 0.2) +\n  geom_sf(data = data_sf, color = \"red\", size = 0.5, alpha = 0.6) +\n  labs(\n    title = \"500m Fishnet Grid over Chicago Graffiti Reports\",\n    subtitle = \"Each square represents a 500m x 500m cell\",\n    caption = \"Data source: Chicago Open Data Portal\"\n  ) +\n  theme_minimal()\n```\n\n\n```{r}\nst_crs(fishnet) <- st_crs(data_proj)\n\nfishnet_counts <- st_join(fishnet, data_proj, join = st_contains)\n\n# Count number of graffiti incidents per grid cell\nfishnet_summary <- fishnet_counts %>%\n  st_drop_geometry() %>%\n  group_by(grid_id) %>%\n  summarise(graffiti_count = n()) %>%\n  right_join(fishnet, by = \"grid_id\") %>%\n  st_as_sf()\n```\n\n```{r}\nggplot() +\n  geom_sf(data = fishnet_summary, aes(fill = graffiti_count), color = \"grey20\") +\n  scale_fill_viridis_c(option = \"plasma\", trans = \"sqrt\") +\n  labs(\n    title = \"500m Fishnet Grid over Chicago Graffiti Reports\",\n    subtitle = \"Graffiti points (red) aggregated within each grid cell\",\n    fill = \"Graffiti Count\"\n  ) +\n  theme_minimal()\n```\n\n\n```{r}\nlibrary(spdep)\n\ndata_sf_grid <- fishnet_summary %>%\n  filter(!is.na(graffiti_count)) %>%\n  mutate(id = row_number())\n```\n```{r}\nnb <- poly2nb(data_sf_grid)\nlw <- nb2listw(nb, style = \"W\", zero.policy = TRUE)\n\nlocal_moran <- localmoran(\n  x = data_sf_grid$graffiti_count,\n  listw = lw,\n  zero.policy = TRUE\n)\n```\n\n```{r}\ndata_sf_grid <- data_sf_grid %>%\n  mutate(\n    local_I = local_moran[, 1],\n    local_p = local_moran[, 5],\n    hot_cold = case_when(\n      local_I > 0 & local_p < 0.05 ~ \"Hot Spot\",\n      local_I < 0 & local_p < 0.05 ~ \"Cold Spot\",\n      TRUE ~ \"Not Significant\"\n    )\n  )\n```\n\n```{r}\nggplot(data_sf_grid) +\n  geom_sf(aes(fill = hot_cold), color = NA) +\n  scale_fill_manual(\n    values = c(\"Hot Spot\" = \"#d7191c\", \"Cold Spot\" = \"#2c7bb6\", \"Not Significant\" = \"grey80\")\n  ) +\n  labs(\n    title = \"Local Moran’s I: Graffiti Removal Hot & Cold Spots\",\n    subtitle = \"City of Chicago, 2024\",\n    fill = \"Cluster Type\"\n  ) +\n  theme_minimal()\n```\n## Step 4: Count Regression Models\n\nIn this step, I built statistical models to predict the number of graffiti removal requests per grid cell, and applied Poisson regression and Negative Binomial regression, which are designed for modeling count data. By comparing model fit using the Akaike Information Criterion (AIC), we can determine which model better captures the spatial variability of graffiti incidents.\n\n```{r}\nlibrary(MASS)\nlibrary(broom)\n\ndata_sf_grid$neighbor_mean <- lag.listw(lw, data_sf_grid$graffiti_count, zero.policy = TRUE)\n\nmodel_poisson <- glm(\n  graffiti_count ~ neighbor_mean + local_I,\n  data = data_sf_grid,\n  family = \"poisson\"\n)\n\nsummary(model_poisson)\n```\n```{r}\nmodel_nb <- glm.nb(\n  graffiti_count ~ neighbor_mean + local_I,\n  data = data_sf_grid\n)\n```\n\n```{r}\naic_comparison <- data.frame(\n  Model = c(\"Poisson\", \"Negative Binomial\"),\n  AIC = c(AIC(model_poisson), AIC(model_nb))\n)\n```\n\n```{r}\npoisson_summary <- tidy(model_poisson)\nnb_summary <- tidy(model_nb)\n\n\nprint(poisson_summary)\nprint(nb_summary)\n```\n```{r}\ndata_sf_grid <- data_sf_grid %>%\n  mutate(\n    pred_poisson = predict(model_poisson, type = \"response\"),\n    pred_nb = predict(model_nb, type = \"response\")\n  )\n\nggplot(data_sf_grid, aes(x = graffiti_count, y = pred_nb)) +\n  geom_point(alpha = 0.4) +\n  geom_smooth(method = \"lm\", color = \"blue\", se = FALSE) +\n  labs(\n    title = \"Observed vs Predicted (Negative Binomial Model)\",\n    x = \"Observed Graffiti Count\",\n    y = \"Predicted Count\"\n  ) +\n  theme_minimal()\n```\n## Step 5: Spatial Cross-Validation\n\nTo assess how well the model generalizes across space, I performed spatial cross-validation. Using a LOGO approach, I trained the model on all grid cells except one spatial group and tested performance on the left-out group.\n\n```{r}\nlibrary(Metrics)\n\nset.seed(42)\ndata_sf_grid$group_id <- kmeans(st_coordinates(st_centroid(data_sf_grid)), centers = 10)$cluster\n\ncv_results <- data.frame(group_id = character(), MAE = numeric(), RMSE = numeric())\n\nfor (g in unique(data_sf_grid$group_id)) {\n\n  train_data <- data_sf_grid[data_sf_grid$group_id != g, ]\n  test_data  <- data_sf_grid[data_sf_grid$group_id == g, ]\n\n  model_cv <- glm(\n    graffiti_count ~ neighbor_mean + local_I,\n    data = train_data,\n    family = \"poisson\"\n  )\n  \n  # Predict on test data\n  test_data$pred <- predict(model_cv, newdata = test_data, type = \"response\")\n  \n  # Compute errors\n  mae_val <- mae(test_data$graffiti_count, test_data$pred)\n  rmse_val <- rmse(test_data$graffiti_count, test_data$pred)\n  \n  # Store results\n  cv_results <- rbind(cv_results, data.frame(group_id = g, MAE = mae_val, RMSE = rmse_val))\n}\n```\n\n```{r}\ncv_summary <- cv_results %>%\n  summarise(\n    Mean_MAE = mean(MAE),\n    Mean_RMSE = mean(RMSE)\n  )\n\nprint(cv_summary)\n```\n```{r}\nggplot(cv_results, aes(x = as.factor(group_id), y = RMSE)) +\n  geom_bar(stat = \"identity\", fill = \"#3182bd\") +\n  labs(\n    title = \"Spatial Cross-Validation (LOGO) RMSE by Group\",\n    x = \"Spatial Group (Community Area)\",\n    y = \"RMSE\"\n  ) +\n  theme_minimal()\n```\n## Step 6: Model Visulization\nIn this step, I evaluated the spatial performance of the Poisson regression model by comparing predicted graffiti counts with the observed counts across the city.\n\nFirst, I generated predicted graffiti counts for each 500m grid cell and computed residuals. Then, I visualized the spatial distribution of these residuals to identify over- and under-predicted areas. Additionally, I compared the regression-based predictions with a KDE map as a baseline.\n\n```{r}\n# Generate predictions and residuals\ndata_sf_grid <- data_sf_grid %>%\n  mutate(\n    predicted = predict(model_poisson, type = \"response\"),\n    residual = graffiti_count - predicted\n  )\n\n# Map observed vs predicted counts\nggplot(data_sf_grid) +\n  geom_sf(aes(fill = predicted), color = NA) +\n  scale_fill_viridis_c(option = \"magma\", trans = \"sqrt\") +\n  labs(\n    title = \"Predicted Graffiti Counts (Poisson Model)\",\n    subtitle = \"City of Chicago, 500m grid\",\n    fill = \"Predicted Count\"\n  ) +\n  theme_minimal()\n```\n```{r}\n# Map residuals (model error)\nggplot(data_sf_grid) +\n  geom_sf(aes(fill = residual), color = NA) +\n  scale_fill_gradient2(\n    low = \"#4575b4\", mid = \"white\", high = \"#d73027\",\n    midpoint = 0\n  ) +\n  labs(\n    title = \"Model Residuals (Observed - Predicted)\",\n    subtitle = \"Blue = under-predicted, Red = over-predicted\",\n    fill = \"Residual\"\n  ) +\n  theme_minimal()\n```\n\n\n```{r}\n# KDE baseline comparison (fixed version)\nlibrary(spatstat)\nlibrary(stars)\n\n# Transform to projected CRS (in meters, for distance-based KDE)\ndata_sf_proj <- st_transform(data_sf, 26971)  # NAD83 / Illinois East (meters)\n\n# Convert to spatstat ppp object\ncoords <- st_coordinates(data_sf_proj)\n\n# Create observation window from study area (fishnet extent)\nwin <- as.owin(st_union(st_geometry(st_transform(data_sf_grid, 26971))))\n\n# Create ppp point pattern\ngraffiti_ppp <- ppp(\n  x = coords[, 1],\n  y = coords[, 2],\n  window = win\n)\n\n# Compute KDE\ngraffiti_kde <- density.ppp(graffiti_ppp, sigma = 500)  # bandwidth = 500m\n\n# Convert to data frame for ggplot\nkde_df <- as.data.frame(graffiti_kde)\ncolnames(kde_df) <- c(\"x\", \"y\", \"density\")\n\n```\n```{r}\nggplot(kde_df, aes(x, y, fill = density)) +\n  geom_raster() +\n  coord_equal() +\n  scale_fill_viridis_c(option = \"inferno\") +\n  labs(\n    title = \"KDE Baseline – Graffiti Removal Density\",\n    subtitle = \"Kernel Density of 311 Graffiti Removal Reports (σ = 500m)\",\n    fill = \"Density\"\n  ) +\n  theme_void()\n```\n## Step 7: Conclusion\n\nThe results revealed clear spatial clustering patterns — high graffiti concentrations were found in central neighborhoods, while peripheral areas showed lower activity. The Negative Binomial model provided a better fit than the Poisson model, suggesting the presence of overdispersion in the data. Spatial cross-validation further confirmed that the model’s predictive accuracy varies across space, performing well in dense urban areas but less accurately in outlying regions.\n\nHowever, the residual analysis showed some underestimation in highly concentrated graffiti areas, indicating that incorporating additional contextual variables, such as land use, population density, or socioeconomic characteristics, could further enhance model accuracy.\n\n","srcMarkdownNoYaml":"\n## Step 1: Data Loading & Preparation\nGraffiti is one of the most common urban maintenance issues in Chicago.\nIn this step, I downloaded the 311 Graffiti Removal service request data from the City of Chicago Data Portal.\n\n```{r}\n# Step 1: Load and Prepare Data\n\nlibrary(tidyverse)\nlibrary(sf)\nlibrary(jsonlite)\nlibrary(lubridate)\n\n# Load Graffiti Removal 311 data from Chicago Open Data API\nurl <- \"https://data.cityofchicago.org/resource/hec5-y4x5.json?$limit=50000\"\n\ndata_raw <- fromJSON(url)\n\n```\n\n```{r}\n# Select and clean relevant columns\ndata_clean <- data_raw %>%\n  select(service_request_number,\n         creation_date,\n         completion_date,\n         status,\n         street_address,\n         latitude,\n         longitude,\n         ward,\n         community_area) %>%\n  mutate(\n    creation_date = ymd_hms(creation_date),\n    completion_date = ymd_hms(completion_date),\n    year = year(creation_date),\n    month = month(creation_date, label = TRUE),\n    day = day(creation_date)\n  ) %>%\n  drop_na(latitude, longitude)\n\n```\n\n```{r}\n# Convert to spatial (sf object)\ndata_sf <- st_as_sf(\n  data_clean,\n  coords = c(\"longitude\", \"latitude\"),\n  crs = 4326\n)\n```\n\n```{r}\nlibrary(ggplot2)\nlibrary(sf)\nlibrary(dplyr)\n\nggplot() +\n  geom_sf(data = data_sf, aes(), \n          color = \"#e41a1c\", alpha = 0.4, size = 0.6) +\n\n  labs(\n    title = \"Spatial Distribution of Street Light Out Reports (Chicago)\",\n    subtitle = \"Each point represents a 311 service request for streetlight outage\",\n    caption = \"Source: City of Chicago Open Data Portal\"\n  ) +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(size = 15, face = \"bold\"),\n    plot.subtitle = element_text(size = 12),\n    plot.caption = element_text(size = 9, color = \"gray40\"),\n    panel.background = element_rect(fill = \"aliceblue\")\n  )\n\n```\n\n## Step 2: Fishnet Grid Creation\nIn this step, I created a 500-meter fishnet grid across the City of Chicago to aggregate the Graffiti Removal 311 requests. By counting how many graffiti reports fall into each grid cell, we can visualize where graffiti problems are concentrated and prepare the data for spatial regression analysis.\n\n```{r}\ndata_proj <- st_transform(data_sf, crs = 26971)\n\nbbox <- st_bbox(data_proj)\n\nfishnet <- st_make_grid(\n  st_as_sfc(bbox),\n  cellsize = 500,\n  square = TRUE\n) %>%\n  st_sf() %>%\n  mutate(grid_id = row_number())\n```\n\n```{r}\n# Visualize the fishnet grid outline\nggplot() +\n  geom_sf(data = fishnet, fill = NA, color = \"grey40\", size = 0.2) +\n  geom_sf(data = data_sf, color = \"red\", size = 0.5, alpha = 0.6) +\n  labs(\n    title = \"500m Fishnet Grid over Chicago Graffiti Reports\",\n    subtitle = \"Each square represents a 500m x 500m cell\",\n    caption = \"Data source: Chicago Open Data Portal\"\n  ) +\n  theme_minimal()\n```\n\n\n```{r}\nst_crs(fishnet) <- st_crs(data_proj)\n\nfishnet_counts <- st_join(fishnet, data_proj, join = st_contains)\n\n# Count number of graffiti incidents per grid cell\nfishnet_summary <- fishnet_counts %>%\n  st_drop_geometry() %>%\n  group_by(grid_id) %>%\n  summarise(graffiti_count = n()) %>%\n  right_join(fishnet, by = \"grid_id\") %>%\n  st_as_sf()\n```\n\n```{r}\nggplot() +\n  geom_sf(data = fishnet_summary, aes(fill = graffiti_count), color = \"grey20\") +\n  scale_fill_viridis_c(option = \"plasma\", trans = \"sqrt\") +\n  labs(\n    title = \"500m Fishnet Grid over Chicago Graffiti Reports\",\n    subtitle = \"Graffiti points (red) aggregated within each grid cell\",\n    fill = \"Graffiti Count\"\n  ) +\n  theme_minimal()\n```\n\n\n```{r}\nlibrary(spdep)\n\ndata_sf_grid <- fishnet_summary %>%\n  filter(!is.na(graffiti_count)) %>%\n  mutate(id = row_number())\n```\n```{r}\nnb <- poly2nb(data_sf_grid)\nlw <- nb2listw(nb, style = \"W\", zero.policy = TRUE)\n\nlocal_moran <- localmoran(\n  x = data_sf_grid$graffiti_count,\n  listw = lw,\n  zero.policy = TRUE\n)\n```\n\n```{r}\ndata_sf_grid <- data_sf_grid %>%\n  mutate(\n    local_I = local_moran[, 1],\n    local_p = local_moran[, 5],\n    hot_cold = case_when(\n      local_I > 0 & local_p < 0.05 ~ \"Hot Spot\",\n      local_I < 0 & local_p < 0.05 ~ \"Cold Spot\",\n      TRUE ~ \"Not Significant\"\n    )\n  )\n```\n\n```{r}\nggplot(data_sf_grid) +\n  geom_sf(aes(fill = hot_cold), color = NA) +\n  scale_fill_manual(\n    values = c(\"Hot Spot\" = \"#d7191c\", \"Cold Spot\" = \"#2c7bb6\", \"Not Significant\" = \"grey80\")\n  ) +\n  labs(\n    title = \"Local Moran’s I: Graffiti Removal Hot & Cold Spots\",\n    subtitle = \"City of Chicago, 2024\",\n    fill = \"Cluster Type\"\n  ) +\n  theme_minimal()\n```\n## Step 4: Count Regression Models\n\nIn this step, I built statistical models to predict the number of graffiti removal requests per grid cell, and applied Poisson regression and Negative Binomial regression, which are designed for modeling count data. By comparing model fit using the Akaike Information Criterion (AIC), we can determine which model better captures the spatial variability of graffiti incidents.\n\n```{r}\nlibrary(MASS)\nlibrary(broom)\n\ndata_sf_grid$neighbor_mean <- lag.listw(lw, data_sf_grid$graffiti_count, zero.policy = TRUE)\n\nmodel_poisson <- glm(\n  graffiti_count ~ neighbor_mean + local_I,\n  data = data_sf_grid,\n  family = \"poisson\"\n)\n\nsummary(model_poisson)\n```\n```{r}\nmodel_nb <- glm.nb(\n  graffiti_count ~ neighbor_mean + local_I,\n  data = data_sf_grid\n)\n```\n\n```{r}\naic_comparison <- data.frame(\n  Model = c(\"Poisson\", \"Negative Binomial\"),\n  AIC = c(AIC(model_poisson), AIC(model_nb))\n)\n```\n\n```{r}\npoisson_summary <- tidy(model_poisson)\nnb_summary <- tidy(model_nb)\n\n\nprint(poisson_summary)\nprint(nb_summary)\n```\n```{r}\ndata_sf_grid <- data_sf_grid %>%\n  mutate(\n    pred_poisson = predict(model_poisson, type = \"response\"),\n    pred_nb = predict(model_nb, type = \"response\")\n  )\n\nggplot(data_sf_grid, aes(x = graffiti_count, y = pred_nb)) +\n  geom_point(alpha = 0.4) +\n  geom_smooth(method = \"lm\", color = \"blue\", se = FALSE) +\n  labs(\n    title = \"Observed vs Predicted (Negative Binomial Model)\",\n    x = \"Observed Graffiti Count\",\n    y = \"Predicted Count\"\n  ) +\n  theme_minimal()\n```\n## Step 5: Spatial Cross-Validation\n\nTo assess how well the model generalizes across space, I performed spatial cross-validation. Using a LOGO approach, I trained the model on all grid cells except one spatial group and tested performance on the left-out group.\n\n```{r}\nlibrary(Metrics)\n\nset.seed(42)\ndata_sf_grid$group_id <- kmeans(st_coordinates(st_centroid(data_sf_grid)), centers = 10)$cluster\n\ncv_results <- data.frame(group_id = character(), MAE = numeric(), RMSE = numeric())\n\nfor (g in unique(data_sf_grid$group_id)) {\n\n  train_data <- data_sf_grid[data_sf_grid$group_id != g, ]\n  test_data  <- data_sf_grid[data_sf_grid$group_id == g, ]\n\n  model_cv <- glm(\n    graffiti_count ~ neighbor_mean + local_I,\n    data = train_data,\n    family = \"poisson\"\n  )\n  \n  # Predict on test data\n  test_data$pred <- predict(model_cv, newdata = test_data, type = \"response\")\n  \n  # Compute errors\n  mae_val <- mae(test_data$graffiti_count, test_data$pred)\n  rmse_val <- rmse(test_data$graffiti_count, test_data$pred)\n  \n  # Store results\n  cv_results <- rbind(cv_results, data.frame(group_id = g, MAE = mae_val, RMSE = rmse_val))\n}\n```\n\n```{r}\ncv_summary <- cv_results %>%\n  summarise(\n    Mean_MAE = mean(MAE),\n    Mean_RMSE = mean(RMSE)\n  )\n\nprint(cv_summary)\n```\n```{r}\nggplot(cv_results, aes(x = as.factor(group_id), y = RMSE)) +\n  geom_bar(stat = \"identity\", fill = \"#3182bd\") +\n  labs(\n    title = \"Spatial Cross-Validation (LOGO) RMSE by Group\",\n    x = \"Spatial Group (Community Area)\",\n    y = \"RMSE\"\n  ) +\n  theme_minimal()\n```\n## Step 6: Model Visulization\nIn this step, I evaluated the spatial performance of the Poisson regression model by comparing predicted graffiti counts with the observed counts across the city.\n\nFirst, I generated predicted graffiti counts for each 500m grid cell and computed residuals. Then, I visualized the spatial distribution of these residuals to identify over- and under-predicted areas. Additionally, I compared the regression-based predictions with a KDE map as a baseline.\n\n```{r}\n# Generate predictions and residuals\ndata_sf_grid <- data_sf_grid %>%\n  mutate(\n    predicted = predict(model_poisson, type = \"response\"),\n    residual = graffiti_count - predicted\n  )\n\n# Map observed vs predicted counts\nggplot(data_sf_grid) +\n  geom_sf(aes(fill = predicted), color = NA) +\n  scale_fill_viridis_c(option = \"magma\", trans = \"sqrt\") +\n  labs(\n    title = \"Predicted Graffiti Counts (Poisson Model)\",\n    subtitle = \"City of Chicago, 500m grid\",\n    fill = \"Predicted Count\"\n  ) +\n  theme_minimal()\n```\n```{r}\n# Map residuals (model error)\nggplot(data_sf_grid) +\n  geom_sf(aes(fill = residual), color = NA) +\n  scale_fill_gradient2(\n    low = \"#4575b4\", mid = \"white\", high = \"#d73027\",\n    midpoint = 0\n  ) +\n  labs(\n    title = \"Model Residuals (Observed - Predicted)\",\n    subtitle = \"Blue = under-predicted, Red = over-predicted\",\n    fill = \"Residual\"\n  ) +\n  theme_minimal()\n```\n\n\n```{r}\n# KDE baseline comparison (fixed version)\nlibrary(spatstat)\nlibrary(stars)\n\n# Transform to projected CRS (in meters, for distance-based KDE)\ndata_sf_proj <- st_transform(data_sf, 26971)  # NAD83 / Illinois East (meters)\n\n# Convert to spatstat ppp object\ncoords <- st_coordinates(data_sf_proj)\n\n# Create observation window from study area (fishnet extent)\nwin <- as.owin(st_union(st_geometry(st_transform(data_sf_grid, 26971))))\n\n# Create ppp point pattern\ngraffiti_ppp <- ppp(\n  x = coords[, 1],\n  y = coords[, 2],\n  window = win\n)\n\n# Compute KDE\ngraffiti_kde <- density.ppp(graffiti_ppp, sigma = 500)  # bandwidth = 500m\n\n# Convert to data frame for ggplot\nkde_df <- as.data.frame(graffiti_kde)\ncolnames(kde_df) <- c(\"x\", \"y\", \"density\")\n\n```\n```{r}\nggplot(kde_df, aes(x, y, fill = density)) +\n  geom_raster() +\n  coord_equal() +\n  scale_fill_viridis_c(option = \"inferno\") +\n  labs(\n    title = \"KDE Baseline – Graffiti Removal Density\",\n    subtitle = \"Kernel Density of 311 Graffiti Removal Reports (σ = 500m)\",\n    fill = \"Density\"\n  ) +\n  theme_void()\n```\n## Step 7: Conclusion\n\nThe results revealed clear spatial clustering patterns — high graffiti concentrations were found in central neighborhoods, while peripheral areas showed lower activity. The Negative Binomial model provided a better fit than the Poisson model, suggesting the presence of overdispersion in the data. Spatial cross-validation further confirmed that the model’s predictive accuracy varies across space, performing well in dense urban areas but less accurately in outlying regions.\n\nHowever, the residual analysis showed some underestimation in highly concentrated graffiti areas, indicating that incorporating additional contextual variables, such as land use, population density, or socioeconomic characteristics, could further enhance model accuracy.\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":"html_document","warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"output-file":"assignment_4.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.8.24","theme":"cosmo","title":"QianmuZheng_Assignment4","date":"2025-11-10"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}