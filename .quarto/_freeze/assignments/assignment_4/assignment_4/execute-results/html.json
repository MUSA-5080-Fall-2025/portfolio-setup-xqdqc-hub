{
  "hash": "7e001cabe1f74a082d3e27932ef8acf8",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"QianmuZheng_Assignment4\"\noutput: html_document\ndate: \"2025-11-10\"\n---\n## Step 1: Data Loading & Preparation\nGraffiti is one of the most common urban maintenance issues in Chicago.\nIn this step, I downloaded the 311 Graffiti Removal service request data from the City of Chicago Data Portal.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Step 1: Load and Prepare Data\n\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.2\n✔ ggplot2   4.0.0     ✔ tibble    3.3.0\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.1.0     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(sf)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLinking to GEOS 3.13.1, GDAL 3.11.0, PROJ 9.6.0; sf_use_s2() is TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(jsonlite)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'jsonlite'\n\nThe following object is masked from 'package:purrr':\n\n    flatten\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(lubridate)\n\n# Load Graffiti Removal 311 data from Chicago Open Data API\nurl <- \"https://data.cityofchicago.org/resource/hec5-y4x5.json?$limit=50000\"\n\ndata_raw <- fromJSON(url)\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Select and clean relevant columns\ndata_clean <- data_raw %>%\n  select(service_request_number,\n         creation_date,\n         completion_date,\n         status,\n         street_address,\n         latitude,\n         longitude,\n         ward,\n         community_area) %>%\n  mutate(\n    creation_date = ymd_hms(creation_date),\n    completion_date = ymd_hms(completion_date),\n    year = year(creation_date),\n    month = month(creation_date, label = TRUE),\n    day = day(creation_date)\n  ) %>%\n  drop_na(latitude, longitude)\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Convert to spatial (sf object)\ndata_sf <- st_as_sf(\n  data_clean,\n  coords = c(\"longitude\", \"latitude\"),\n  crs = 4326\n)\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(sf)\nlibrary(dplyr)\n\nggplot() +\n  geom_sf(data = data_sf, aes(), \n          color = \"#e41a1c\", alpha = 0.4, size = 0.6) +\n\n  labs(\n    title = \"Spatial Distribution of Street Light Out Reports (Chicago)\",\n    subtitle = \"Each point represents a 311 service request for streetlight outage\",\n    caption = \"Source: City of Chicago Open Data Portal\"\n  ) +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(size = 15, face = \"bold\"),\n    plot.subtitle = element_text(size = 12),\n    plot.caption = element_text(size = 9, color = \"gray40\"),\n    panel.background = element_rect(fill = \"aliceblue\")\n  )\n```\n\n::: {.cell-output-display}\n![](assignment_4_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\n## Step 2: Fishnet Grid Creation\nIn this step, I created a 500-meter fishnet grid across the City of Chicago to aggregate the Graffiti Removal 311 requests. By counting how many graffiti reports fall into each grid cell, we can visualize where graffiti problems are concentrated and prepare the data for spatial regression analysis.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_proj <- st_transform(data_sf, crs = 26971)\n\nbbox <- st_bbox(data_proj)\n\nfishnet <- st_make_grid(\n  st_as_sfc(bbox),\n  cellsize = 500,\n  square = TRUE\n) %>%\n  st_sf() %>%\n  mutate(grid_id = row_number())\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Visualize the fishnet grid outline\nggplot() +\n  geom_sf(data = fishnet, fill = NA, color = \"grey40\", size = 0.2) +\n  geom_sf(data = data_sf, color = \"red\", size = 0.5, alpha = 0.6) +\n  labs(\n    title = \"500m Fishnet Grid over Chicago Graffiti Reports\",\n    subtitle = \"Each square represents a 500m x 500m cell\",\n    caption = \"Data source: Chicago Open Data Portal\"\n  ) +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](assignment_4_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_crs(fishnet) <- st_crs(data_proj)\n\nfishnet_counts <- st_join(fishnet, data_proj, join = st_contains)\n\n# Count number of graffiti incidents per grid cell\nfishnet_summary <- fishnet_counts %>%\n  st_drop_geometry() %>%\n  group_by(grid_id) %>%\n  summarise(graffiti_count = n()) %>%\n  right_join(fishnet, by = \"grid_id\") %>%\n  st_as_sf()\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() +\n  geom_sf(data = fishnet_summary, aes(fill = graffiti_count), color = \"grey20\") +\n  scale_fill_viridis_c(option = \"plasma\", trans = \"sqrt\") +\n  labs(\n    title = \"500m Fishnet Grid over Chicago Graffiti Reports\",\n    subtitle = \"Graffiti points (red) aggregated within each grid cell\",\n    fill = \"Graffiti Count\"\n  ) +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](assignment_4_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(spdep)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: spData\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nTo access larger datasets in this package, install the spDataLarge\npackage with: `install.packages('spDataLarge',\nrepos='https://nowosad.github.io/drat/', type='source')`\n```\n\n\n:::\n\n```{.r .cell-code}\ndata_sf_grid <- fishnet_summary %>%\n  filter(!is.na(graffiti_count)) %>%\n  mutate(id = row_number())\n```\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnb <- poly2nb(data_sf_grid)\nlw <- nb2listw(nb, style = \"W\", zero.policy = TRUE)\n\nlocal_moran <- localmoran(\n  x = data_sf_grid$graffiti_count,\n  listw = lw,\n  zero.policy = TRUE\n)\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_sf_grid <- data_sf_grid %>%\n  mutate(\n    local_I = local_moran[, 1],\n    local_p = local_moran[, 5],\n    hot_cold = case_when(\n      local_I > 0 & local_p < 0.05 ~ \"Hot Spot\",\n      local_I < 0 & local_p < 0.05 ~ \"Cold Spot\",\n      TRUE ~ \"Not Significant\"\n    )\n  )\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data_sf_grid) +\n  geom_sf(aes(fill = hot_cold), color = NA) +\n  scale_fill_manual(\n    values = c(\"Hot Spot\" = \"#d7191c\", \"Cold Spot\" = \"#2c7bb6\", \"Not Significant\" = \"grey80\")\n  ) +\n  labs(\n    title = \"Local Moran’s I: Graffiti Removal Hot & Cold Spots\",\n    subtitle = \"City of Chicago, 2024\",\n    fill = \"Cluster Type\"\n  ) +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](assignment_4_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n## Step 4: Count Regression Models\n\nIn this step, I built statistical models to predict the number of graffiti removal requests per grid cell, and applied Poisson regression and Negative Binomial regression, which are designed for modeling count data. By comparing model fit using the Akaike Information Criterion (AIC), we can determine which model better captures the spatial variability of graffiti incidents.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(MASS)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'MASS'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following object is masked from 'package:dplyr':\n\n    select\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(broom)\n\ndata_sf_grid$neighbor_mean <- lag.listw(lw, data_sf_grid$graffiti_count, zero.policy = TRUE)\n\nmodel_poisson <- glm(\n  graffiti_count ~ neighbor_mean + local_I,\n  data = data_sf_grid,\n  family = \"poisson\"\n)\n\nsummary(model_poisson)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nglm(formula = graffiti_count ~ neighbor_mean + local_I, family = \"poisson\", \n    data = data_sf_grid)\n\nCoefficients:\n               Estimate Std. Error z value Pr(>|z|)    \n(Intercept)   1.559e+00  6.395e-03  243.74   <2e-16 ***\nneighbor_mean 2.583e-02  9.574e-05  269.85   <2e-16 ***\nlocal_I       1.704e-02  4.149e-04   41.08   <2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n(Dispersion parameter for poisson family taken to be 1)\n\n    Null deviance: 168377  on 4896  degrees of freedom\nResidual deviance:  60455  on 4894  degrees of freedom\nAIC: 74000\n\nNumber of Fisher Scoring iterations: 6\n```\n\n\n:::\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_nb <- glm.nb(\n  graffiti_count ~ neighbor_mean + local_I,\n  data = data_sf_grid\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: glm.fit: algorithm did not converge\nWarning: glm.fit: algorithm did not converge\nWarning: glm.fit: algorithm did not converge\nWarning: glm.fit: algorithm did not converge\nWarning: glm.fit: algorithm did not converge\nWarning: glm.fit: algorithm did not converge\nWarning: glm.fit: algorithm did not converge\nWarning: glm.fit: algorithm did not converge\nWarning: glm.fit: algorithm did not converge\nWarning: glm.fit: algorithm did not converge\nWarning: glm.fit: algorithm did not converge\nWarning: glm.fit: algorithm did not converge\nWarning: glm.fit: algorithm did not converge\nWarning: glm.fit: algorithm did not converge\nWarning: glm.fit: algorithm did not converge\nWarning: glm.fit: algorithm did not converge\nWarning: glm.fit: algorithm did not converge\nWarning: glm.fit: algorithm did not converge\nWarning: glm.fit: algorithm did not converge\nWarning: glm.fit: algorithm did not converge\nWarning: glm.fit: algorithm did not converge\nWarning: glm.fit: algorithm did not converge\nWarning: glm.fit: algorithm did not converge\nWarning: glm.fit: algorithm did not converge\nWarning: glm.fit: algorithm did not converge\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in glm.nb(graffiti_count ~ neighbor_mean + local_I, data =\ndata_sf_grid): alternation limit reached\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\naic_comparison <- data.frame(\n  Model = c(\"Poisson\", \"Negative Binomial\"),\n  AIC = c(AIC(model_poisson), AIC(model_nb))\n)\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npoisson_summary <- tidy(model_poisson)\nnb_summary <- tidy(model_nb)\n\n\nprint(poisson_summary)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 5\n  term          estimate std.error statistic p.value\n  <chr>            <dbl>     <dbl>     <dbl>   <dbl>\n1 (Intercept)     1.56   0.00640       244.        0\n2 neighbor_mean   0.0258 0.0000957     270.        0\n3 local_I         0.0170 0.000415       41.1       0\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(nb_summary)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 5\n  term          estimate std.error statistic   p.value\n  <chr>            <dbl>     <dbl>     <dbl>     <dbl>\n1 (Intercept)     0.655   0.0179       36.7  2.88e-294\n2 neighbor_mean   0.0637  0.000776     82.2  0        \n3 local_I        -0.0564  0.00615      -9.18 4.26e- 20\n```\n\n\n:::\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_sf_grid <- data_sf_grid %>%\n  mutate(\n    pred_poisson = predict(model_poisson, type = \"response\"),\n    pred_nb = predict(model_nb, type = \"response\")\n  )\n\nggplot(data_sf_grid, aes(x = graffiti_count, y = pred_nb)) +\n  geom_point(alpha = 0.4) +\n  geom_smooth(method = \"lm\", color = \"blue\", se = FALSE) +\n  labs(\n    title = \"Observed vs Predicted (Negative Binomial Model)\",\n    x = \"Observed Graffiti Count\",\n    y = \"Predicted Count\"\n  ) +\n  theme_minimal()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`geom_smooth()` using formula = 'y ~ x'\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](assignment_4_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n## Step 5: Spatial Cross-Validation\n\nTo assess how well the model generalizes across space, I performed spatial cross-validation. Using a LOGO approach, I trained the model on all grid cells except one spatial group and tested performance on the left-out group.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(Metrics)\n\nset.seed(42)\ndata_sf_grid$group_id <- kmeans(st_coordinates(st_centroid(data_sf_grid)), centers = 10)$cluster\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: st_centroid assumes attributes are constant over geometries\n```\n\n\n:::\n\n```{.r .cell-code}\ncv_results <- data.frame(group_id = character(), MAE = numeric(), RMSE = numeric())\n\nfor (g in unique(data_sf_grid$group_id)) {\n\n  train_data <- data_sf_grid[data_sf_grid$group_id != g, ]\n  test_data  <- data_sf_grid[data_sf_grid$group_id == g, ]\n\n  model_cv <- glm(\n    graffiti_count ~ neighbor_mean + local_I,\n    data = train_data,\n    family = \"poisson\"\n  )\n  \n  # Predict on test data\n  test_data$pred <- predict(model_cv, newdata = test_data, type = \"response\")\n  \n  # Compute errors\n  mae_val <- mae(test_data$graffiti_count, test_data$pred)\n  rmse_val <- rmse(test_data$graffiti_count, test_data$pred)\n  \n  # Store results\n  cv_results <- rbind(cv_results, data.frame(group_id = g, MAE = mae_val, RMSE = rmse_val))\n}\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncv_summary <- cv_results %>%\n  summarise(\n    Mean_MAE = mean(MAE),\n    Mean_RMSE = mean(RMSE)\n  )\n\nprint(cv_summary)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Mean_MAE Mean_RMSE\n1 9.996916  18.55191\n```\n\n\n:::\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(cv_results, aes(x = as.factor(group_id), y = RMSE)) +\n  geom_bar(stat = \"identity\", fill = \"#3182bd\") +\n  labs(\n    title = \"Spatial Cross-Validation (LOGO) RMSE by Group\",\n    x = \"Spatial Group (Community Area)\",\n    y = \"RMSE\"\n  ) +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](assignment_4_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n## Step 6: Model Visulization\nIn this step, I evaluated the spatial performance of the Poisson regression model by comparing predicted graffiti counts with the observed counts across the city.\n\nFirst, I generated predicted graffiti counts for each 500m grid cell and computed residuals. Then, I visualized the spatial distribution of these residuals to identify over- and under-predicted areas. Additionally, I compared the regression-based predictions with a KDE map as a baseline.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Generate predictions and residuals\ndata_sf_grid <- data_sf_grid %>%\n  mutate(\n    predicted = predict(model_poisson, type = \"response\"),\n    residual = graffiti_count - predicted\n  )\n\n# Map observed vs predicted counts\nggplot(data_sf_grid) +\n  geom_sf(aes(fill = predicted), color = NA) +\n  scale_fill_viridis_c(option = \"magma\", trans = \"sqrt\") +\n  labs(\n    title = \"Predicted Graffiti Counts (Poisson Model)\",\n    subtitle = \"City of Chicago, 500m grid\",\n    fill = \"Predicted Count\"\n  ) +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](assignment_4_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Map residuals (model error)\nggplot(data_sf_grid) +\n  geom_sf(aes(fill = residual), color = NA) +\n  scale_fill_gradient2(\n    low = \"#4575b4\", mid = \"white\", high = \"#d73027\",\n    midpoint = 0\n  ) +\n  labs(\n    title = \"Model Residuals (Observed - Predicted)\",\n    subtitle = \"Blue = under-predicted, Red = over-predicted\",\n    fill = \"Residual\"\n  ) +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](assignment_4_files/figure-html/unnamed-chunk-22-1.png){width=672}\n:::\n:::\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# KDE baseline comparison (fixed version)\nlibrary(spatstat)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: package 'spatstat' was built under R version 4.5.2\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: spatstat.data\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: package 'spatstat.data' was built under R version 4.5.2\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: spatstat.univar\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: package 'spatstat.univar' was built under R version 4.5.2\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nspatstat.univar 3.1-4\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: spatstat.geom\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: package 'spatstat.geom' was built under R version 4.5.2\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nspatstat.geom 3.6-0\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'spatstat.geom'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following object is masked from 'package:MASS':\n\n    area\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: spatstat.random\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: package 'spatstat.random' was built under R version 4.5.2\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nspatstat.random 3.4-2\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: spatstat.explore\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: package 'spatstat.explore' was built under R version 4.5.2\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: nlme\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'nlme'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following object is masked from 'package:dplyr':\n\n    collapse\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nspatstat.explore 3.5-3\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'spatstat.explore'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following object is masked from 'package:Metrics':\n\n    auc\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: spatstat.model\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: package 'spatstat.model' was built under R version 4.5.2\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: rpart\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nspatstat.model 3.4-2\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: spatstat.linnet\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: package 'spatstat.linnet' was built under R version 4.5.2\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nspatstat.linnet 3.3-2\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nspatstat 3.4-1 \nFor an introduction to spatstat, type 'beginner' \n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(stars)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: abind\n```\n\n\n:::\n\n```{.r .cell-code}\n# Transform to projected CRS (in meters, for distance-based KDE)\ndata_sf_proj <- st_transform(data_sf, 26971)  # NAD83 / Illinois East (meters)\n\n# Convert to spatstat ppp object\ncoords <- st_coordinates(data_sf_proj)\n\n# Create observation window from study area (fishnet extent)\nwin <- as.owin(st_union(st_geometry(st_transform(data_sf_grid, 26971))))\n\n# Create ppp point pattern\ngraffiti_ppp <- ppp(\n  x = coords[, 1],\n  y = coords[, 2],\n  window = win\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: data contain duplicated points\n```\n\n\n:::\n\n```{.r .cell-code}\n# Compute KDE\ngraffiti_kde <- density.ppp(graffiti_ppp, sigma = 500)  # bandwidth = 500m\n\n# Convert to data frame for ggplot\nkde_df <- as.data.frame(graffiti_kde)\ncolnames(kde_df) <- c(\"x\", \"y\", \"density\")\n```\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(kde_df, aes(x, y, fill = density)) +\n  geom_raster() +\n  coord_equal() +\n  scale_fill_viridis_c(option = \"inferno\") +\n  labs(\n    title = \"KDE Baseline – Graffiti Removal Density\",\n    subtitle = \"Kernel Density of 311 Graffiti Removal Reports (σ = 500m)\",\n    fill = \"Density\"\n  ) +\n  theme_void()\n```\n\n::: {.cell-output-display}\n![](assignment_4_files/figure-html/unnamed-chunk-24-1.png){width=672}\n:::\n:::\n\n## Step 7: Conclusion\n\nThe results revealed clear spatial clustering patterns — high graffiti concentrations were found in central neighborhoods, while peripheral areas showed lower activity. The Negative Binomial model provided a better fit than the Poisson model, suggesting the presence of overdispersion in the data. Spatial cross-validation further confirmed that the model’s predictive accuracy varies across space, performing well in dense urban areas but less accurately in outlying regions.\n\nHowever, the residual analysis showed some underestimation in highly concentrated graffiti areas, indicating that incorporating additional contextual variables, such as land use, population density, or socioeconomic characteristics, could further enhance model accuracy.\n\n",
    "supporting": [
      "assignment_4_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}